const { Client } = require('whatsapp-web.js');
const qrcode = require('qrcode-terminal');
const schedule = require('node-schedule');
const axios = require('axios');
const fs = require('fs').promises;
const path = require('path');
require('dotenv').config();
const axiosRetry = require('axios-retry').default;
const chalk = require('chalk');

// Configuração de retry automático para requisições HTTP
axiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
if (!OPENAI_API_KEY) {
  console.error('❌ OPENAI_API_KEY não encontrada no .env. Abortando...');
  process.exit(1);
}

// Caminhos de arquivos
const gruposSyncPath = path.join(__dirname, 'gruposIDs', 'grupos_sincronizados.json');
const gruposNaoSyncPath = path.join(__dirname, 'gruposIDs', 'grupos_nao_sincronizados.json');
const mensagensEnviadasPath = path.join(__dirname, 'historico', 'mensagens_enviadas.json');

const client = new Client();
let gruposValidos = [];

// === Eventos do WhatsApp Web ===

client.on('qr', qr => {
  console.clear();
  console.log(chalk.green('📲 Escaneie este QR Code com o WhatsApp Web:'));
  qrcode.generate(qr, { small: true });
});

client.on('ready', async () => {
  console.log(chalk.green('✅ Bot conectado com sucesso!'));
  console.log(chalk.gray('🔄 Sincronizando grupos do WhatsApp...'));

  const chats = await client.getChats();
  const todosGrupos = chats.filter(c => c.isGroup).map(g => ({
    id: g.id._serialized,
    name: g.name
  }));

  console.log(chalk.green(🔍 ${todosGrupos.length} grupos encontrados.));

  let gruposSalvos = [];
  try {
    const data = await fs.readFile(gruposSyncPath, 'utf-8');
    gruposSalvos = JSON.parse(data);
  } catch {
    console.warn(chalk.yellow('⚠️ Arquivo de grupos sincronizados não encontrado.'));
  }

  // Verifica quais grupos ainda estão ativos
  gruposValidos = gruposSalvos.filter(g => todosGrupos.some(c => c.id === g.id));
  console.log(chalk.green(✅ ${gruposValidos.length} grupos sincronizados:));
  gruposValidos.forEach(g =>
    console.log(chalk.bgBlue(• ${g.curso || g.name} (${g.id})))
  );

  // Atualiza o arquivo se necessário
  const novoConteudo = JSON.stringify(gruposValidos, null, 2);
  try {
    const antigoConteudo = await fs.readFile(gruposSyncPath, 'utf-8');
    if (antigoConteudo !== novoConteudo) {
      await fs.mkdir(path.dirname(gruposSyncPath), { recursive: true });
      await fs.writeFile(gruposSyncPath, novoConteudo, 'utf-8');
      console.log(💾 Grupos sincronizados salvos em: ${gruposSyncPath});
    } else {
      console.log(chalk.gray('📁 Nenhuma mudança nos grupos sincronizados.'));
    }
  } catch {
    await fs.mkdir(path.dirname(gruposSyncPath), { recursive: true });
    await fs.writeFile(gruposSyncPath, novoConteudo, 'utf-8');
    console.log(💾 Grupos sincronizados salvos em: ${gruposSyncPath});
  }

  // Identifica grupos não sincronizados
  const naoSincronizados = todosGrupos.filter(
    g => !gruposValidos.some(s => s.id === g.id)
  );
  const novoNaoSync = JSON.stringify(naoSincronizados, null, 2);
  try {
    const antigoNaoSync = await fs.readFile(gruposNaoSyncPath, 'utf-8');
    if (antigoNaoSync !== novoNaoSync) {
      await fs.mkdir(path.dirname(gruposNaoSyncPath), { recursive: true });
      await fs.writeFile(gruposNaoSyncPath, novoNaoSync, 'utf-8');
      console.log(📁 Grupos não sincronizados salvos em: ${gruposNaoSyncPath});
    } else {
      console.log(chalk.gray('📁 Nenhuma mudança nos grupos não sincronizados.'));
    }
  } catch {
    await fs.mkdir(path.dirname(gruposNaoSyncPath), { recursive: true });
    await fs.writeFile(gruposNaoSyncPath, novoNaoSync, 'utf-8');
    console.log(📁 Grupos não sincronizados salvos em: ${gruposNaoSyncPath});
  }

  // Agendamento: a cada 3 minutos (mude para "0 10 */3 * *" para a cada 3 dias às 10h)
  const jobRule = '*/3 * * * *';
  const agendamento = schedule.scheduleJob('mensagem-a-cada-3-dias', jobRule, async () => {
    console.log(chalk.cyan(📅 Enviando mensagens em: ${new Date().toLocaleString()}));
    await enviarMensagensEmLote(gruposValidos);

    const proximaExecucao = agendamento.nextInvocation();
    console.log(chalk.blue(⏳ Próximo envio: ${proximaExecucao.toLocaleString()}));
  });

  console.log(chalk.blackBright(🕒 Aguardando até ${agendamento.nextInvocation().toLocaleString()} para envio das mensagens...));

  // Exibe contagem regressiva no console
  const readline = require('readline');
  setInterval(() => {
    readline.clearLine(process.stdout, 0);
    readline.cursorTo(process.stdout, 0);
    process.stdout.write(⌛ Tempo restante: ${h}h ${m}m ${s}s);
  }, 1000);
});

// Mensagens recebidas
client.on('message', msg => {
  if (msg.from.endsWith('@g.us')) {
    console.log(chalk.gray(📥 Mensagem recebida do grupo: ${msg.from}));
  }
});

// Eventos de erro
client.on('disconnected', reason => {
  console.warn(chalk.yellow(🔌 Desconectado: ${reason}));
});
client.on('auth_failure', msg => {
  console.error(chalk.red('❌ Falha de autenticação:', msg));
});

client.initialize();

// === Funções Auxiliares ===

async function salvarMensagemNoHistorico(grupoId, mensagem, grupoNome) {
  try {
    let historico = {};
    try {
      const data = await fs.readFile(mensagensEnviadasPath, 'utf-8');
      historico = JSON.parse(data);
    } catch {
      await fs.mkdir(path.dirname(mensagensEnviadasPath), { recursive: true });
    }

    if (!historico[grupoId]) historico[grupoId] = [];

    historico[grupoId].push({
      nomeGrupo: grupoNome,
      mensagem,
      horario: new Date().toLocaleString()
    });

    await fs.writeFile(mensagensEnviadasPath, JSON.stringify(historico, null, 2), 'utf-8');
  } catch (err) {
    console.error(chalk.red('❌ Erro ao salvar no histórico:', err.message));
  }
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function enviarMensagensEmLote(grupos) {
  for (let i = 0; i < grupos.length; i++) {
    const grupo = grupos[i];

    if (i !== 0) {
      console.log(chalk.gray(⏳ Aguardando 15s antes de enviar para "${grupo.curso || grupo.name}"...));
      await delay(15000);
    } else {
      console.log(chalk.gray(⏩ Enviando imediatamente para o primeiro grupo "${grupo.curso || grupo.name}".));
    }

    const enviado = await enviarMensagemParaGrupo(grupo);

    if (!enviado) {
      console.log(chalk.gray(⏩ Nenhuma mensagem enviada para "${grupo.curso || grupo.name}".));
    }
  }
}

async function enviarMensagemParaGrupo(grupo) {
  try {
    const nomeGrupo = grupo.curso || grupo.name || 'Grupo desconhecido';
    let mensagem = await gerarMensagemIA(nomeGrupo, grupo.id);

    let historico = {};
    try {
      const data = await fs.readFile(mensagensEnviadasPath, 'utf-8');
      historico = JSON.parse(data);
    } catch {}

    const mensagensAntigas = historico[grupo.id]?.map(m => m.mensagem.trim()) || [];
    const ultimas = mensagensAntigas.slice(-10);

    let tentativas = 0;
    const MAX = 3;

    while (ultimas.includes(mensagem.trim()) && tentativas < MAX) {
      console.log(chalk.yellow(🔁 Mensagem repetida para "${nomeGrupo}". Gerando nova...));
      mensagem = await gerarMensagemIA(nomeGrupo, grupo.id);
      tentativas++;
    }

    if (!ultimas.includes(mensagem.trim())) {
      await client.sendMessage(grupo.id, mensagem);
      await salvarMensagemNoHistorico(grupo.id, mensagem, nomeGrupo);
      console.log(chalk.green(📤 Mensagem enviada para "${nomeGrupo}"));
      return true;
    }

    return false;
  } catch (err) {
    console.error(chalk.red(❌ Falha ao enviar mensagem para "${grupo.name}": ${err.message}));
    return false;
  }
}

// extrai o texto do pdf
const pdfParse = require('pdf-parse');
const { read } = require('fs');

async function gerarMensagemIA(nomeGrupoOuCurso, grupoId) {
  try {
    const pdfPath = path.join(__dirname, 'PDFs', ${grupoId}.pdf);

    // Verifica se o PDF existe
    let pdfText = '';
    try {
      const dataBuffer = await fs.readFile(pdfPath);
      const pdfData = await pdfParse(dataBuffer);
      pdfText = pdfData.text.trim().slice(0, 10000); // Limita para evitar excesso
    } catch (e) {
      console.warn(chalk.yellow(⚠️ PDF não encontrado ou erro ao ler para o grupo ${grupoId}. Gerando mensagem genérica.));
    }

    // Prompt base
    const prompt = pdfText
      ? Você é uma pessoa que cuida de um grupo no WhatsApp de um curso chamado "${nomeGrupoOuCurso}". Com base nesse trecho do material do curso:\n\n"${pdfText}"\n\nEscreva uma mensagem de tamanho media e natural para o grupo, como se fosse um colega falando com os alunos. Evite parecer uma IA ou uma mensagem de marketing. Pode comentar algo que achou interessante do conteúdo, fazer uma pergunta para o grupo ou dar um toque simples, como um lembrete ou novidade. Nada de hashtags, listas, links ou mensagens muito longas.
      : Escreva uma mensagem curta e natural para um grupo de WhatsApp do curso "${nomeGrupoOuCurso}", como se fosse um colega animando os alunos. Pode dar uma dica, contar uma novidade ou só puxar conversa. Evite listas, hashtags, links ou parecer uma IA. Use uma linguagem simples e direta.;

    const { data } = await axios.post(
      'https://api.groq.com/openai/v1/chat/completions',
      {
        model: 'meta-llama/llama-4-scout-17b-16e-instruct',
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.7,
        max_tokens: parseInt(process.env.OPENAI_MAX_TOKENS) || 3900
      },
      {
        headers: {
          'Authorization': Bearer ${OPENAI_API_KEY},
          'Content-Type': 'application/json'
        }
      }
    );
  
  const respostaIA = data?.choices?.[0]?.message?.content;
  if (!respostaIA) {
    throw new Error('Resposta da IA vazia ou invalida.');
  }

  return respostaIA.trim();
  } catch (err) {
    console.error(chalk.red(❌ Erro ao gerar mensagem para grupo ${grupoId}:, err.message));
    return Olá! Hoje é um bom momento para revisar os conteúdos do curso "${nomeGrupoOuCurso}". Em breve enviaremos novidades!;
  }
}