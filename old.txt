const { Client } = require('whatsapp-web.js');
const qrcode = require('qrcode-terminal');
const schedule = require('node-schedule');
const axios = require('axios');
const fs = require('fs').promises;
const path = require('path');
require('dotenv').config();
const axiosRetry = require('axios-retry').default;
const chalk = require('chalk');

// ConfiguraÃ§Ã£o de retry automÃ¡tico para requisiÃ§Ãµes HTTP
axiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
if (!OPENAI_API_KEY) {
  console.error('âŒ OPENAI_API_KEY nÃ£o encontrada no .env. Abortando...');
  process.exit(1);
}

// Caminhos de arquivos
const gruposSyncPath = path.join(__dirname, 'gruposIDs', 'grupos_sincronizados.json');
const gruposNaoSyncPath = path.join(__dirname, 'gruposIDs', 'grupos_nao_sincronizados.json');
const mensagensEnviadasPath = path.join(__dirname, 'historico', 'mensagens_enviadas.json');

const client = new Client();
let gruposValidos = [];

// === Eventos do WhatsApp Web ===

client.on('qr', qr => {
  console.clear();
  console.log(chalk.green('ðŸ“² Escaneie este QR Code com o WhatsApp Web:'));
  qrcode.generate(qr, { small: true });
});

client.on('ready', async () => {
  console.log(chalk.green('âœ… Bot conectado com sucesso!'));
  console.log(chalk.gray('ðŸ”„ Sincronizando grupos do WhatsApp...'));

  const chats = await client.getChats();
  const todosGrupos = chats.filter(c => c.isGroup).map(g => ({
    id: g.id._serialized,
    name: g.name
  }));

  console.log(chalk.green(ðŸ” ${todosGrupos.length} grupos encontrados.));

  let gruposSalvos = [];
  try {
    const data = await fs.readFile(gruposSyncPath, 'utf-8');
    gruposSalvos = JSON.parse(data);
  } catch {
    console.warn(chalk.yellow('âš ï¸ Arquivo de grupos sincronizados nÃ£o encontrado.'));
  }

  // Verifica quais grupos ainda estÃ£o ativos
  gruposValidos = gruposSalvos.filter(g => todosGrupos.some(c => c.id === g.id));
  console.log(chalk.green(âœ… ${gruposValidos.length} grupos sincronizados:));
  gruposValidos.forEach(g =>
    console.log(chalk.bgBlue(â€¢ ${g.curso || g.name} (${g.id})))
  );

  // Atualiza o arquivo se necessÃ¡rio
  const novoConteudo = JSON.stringify(gruposValidos, null, 2);
  try {
    const antigoConteudo = await fs.readFile(gruposSyncPath, 'utf-8');
    if (antigoConteudo !== novoConteudo) {
      await fs.mkdir(path.dirname(gruposSyncPath), { recursive: true });
      await fs.writeFile(gruposSyncPath, novoConteudo, 'utf-8');
      console.log(ðŸ’¾ Grupos sincronizados salvos em: ${gruposSyncPath});
    } else {
      console.log(chalk.gray('ðŸ“ Nenhuma mudanÃ§a nos grupos sincronizados.'));
    }
  } catch {
    await fs.mkdir(path.dirname(gruposSyncPath), { recursive: true });
    await fs.writeFile(gruposSyncPath, novoConteudo, 'utf-8');
    console.log(ðŸ’¾ Grupos sincronizados salvos em: ${gruposSyncPath});
  }

  // Identifica grupos nÃ£o sincronizados
  const naoSincronizados = todosGrupos.filter(
    g => !gruposValidos.some(s => s.id === g.id)
  );
  const novoNaoSync = JSON.stringify(naoSincronizados, null, 2);
  try {
    const antigoNaoSync = await fs.readFile(gruposNaoSyncPath, 'utf-8');
    if (antigoNaoSync !== novoNaoSync) {
      await fs.mkdir(path.dirname(gruposNaoSyncPath), { recursive: true });
      await fs.writeFile(gruposNaoSyncPath, novoNaoSync, 'utf-8');
      console.log(ðŸ“ Grupos nÃ£o sincronizados salvos em: ${gruposNaoSyncPath});
    } else {
      console.log(chalk.gray('ðŸ“ Nenhuma mudanÃ§a nos grupos nÃ£o sincronizados.'));
    }
  } catch {
    await fs.mkdir(path.dirname(gruposNaoSyncPath), { recursive: true });
    await fs.writeFile(gruposNaoSyncPath, novoNaoSync, 'utf-8');
    console.log(ðŸ“ Grupos nÃ£o sincronizados salvos em: ${gruposNaoSyncPath});
  }

  // Agendamento: a cada 3 minutos (mude para "0 10 */3 * *" para a cada 3 dias Ã s 10h)
  const jobRule = '*/3 * * * *';
  const agendamento = schedule.scheduleJob('mensagem-a-cada-3-dias', jobRule, async () => {
    console.log(chalk.cyan(ðŸ“… Enviando mensagens em: ${new Date().toLocaleString()}));
    await enviarMensagensEmLote(gruposValidos);

    const proximaExecucao = agendamento.nextInvocation();
    console.log(chalk.blue(â³ PrÃ³ximo envio: ${proximaExecucao.toLocaleString()}));
  });

  console.log(chalk.blackBright(ðŸ•’ Aguardando atÃ© ${agendamento.nextInvocation().toLocaleString()} para envio das mensagens...));

  // Exibe contagem regressiva no console
  const readline = require('readline');
  setInterval(() => {
    readline.clearLine(process.stdout, 0);
    readline.cursorTo(process.stdout, 0);
    process.stdout.write(âŒ› Tempo restante: ${h}h ${m}m ${s}s);
  }, 1000);
});

// Mensagens recebidas
client.on('message', msg => {
  if (msg.from.endsWith('@g.us')) {
    console.log(chalk.gray(ðŸ“¥ Mensagem recebida do grupo: ${msg.from}));
  }
});

// Eventos de erro
client.on('disconnected', reason => {
  console.warn(chalk.yellow(ðŸ”Œ Desconectado: ${reason}));
});
client.on('auth_failure', msg => {
  console.error(chalk.red('âŒ Falha de autenticaÃ§Ã£o:', msg));
});

client.initialize();

// === FunÃ§Ãµes Auxiliares ===

async function salvarMensagemNoHistorico(grupoId, mensagem, grupoNome) {
  try {
    let historico = {};
    try {
      const data = await fs.readFile(mensagensEnviadasPath, 'utf-8');
      historico = JSON.parse(data);
    } catch {
      await fs.mkdir(path.dirname(mensagensEnviadasPath), { recursive: true });
    }

    if (!historico[grupoId]) historico[grupoId] = [];

    historico[grupoId].push({
      nomeGrupo: grupoNome,
      mensagem,
      horario: new Date().toLocaleString()
    });

    await fs.writeFile(mensagensEnviadasPath, JSON.stringify(historico, null, 2), 'utf-8');
  } catch (err) {
    console.error(chalk.red('âŒ Erro ao salvar no histÃ³rico:', err.message));
  }
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function enviarMensagensEmLote(grupos) {
  for (let i = 0; i < grupos.length; i++) {
    const grupo = grupos[i];

    if (i !== 0) {
      console.log(chalk.gray(â³ Aguardando 15s antes de enviar para "${grupo.curso || grupo.name}"...));
      await delay(15000);
    } else {
      console.log(chalk.gray(â© Enviando imediatamente para o primeiro grupo "${grupo.curso || grupo.name}".));
    }

    const enviado = await enviarMensagemParaGrupo(grupo);

    if (!enviado) {
      console.log(chalk.gray(â© Nenhuma mensagem enviada para "${grupo.curso || grupo.name}".));
    }
  }
}

async function enviarMensagemParaGrupo(grupo) {
  try {
    const nomeGrupo = grupo.curso || grupo.name || 'Grupo desconhecido';
    let mensagem = await gerarMensagemIA(nomeGrupo, grupo.id);

    let historico = {};
    try {
      const data = await fs.readFile(mensagensEnviadasPath, 'utf-8');
      historico = JSON.parse(data);
    } catch {}

    const mensagensAntigas = historico[grupo.id]?.map(m => m.mensagem.trim()) || [];
    const ultimas = mensagensAntigas.slice(-10);

    let tentativas = 0;
    const MAX = 3;

    while (ultimas.includes(mensagem.trim()) && tentativas < MAX) {
      console.log(chalk.yellow(ðŸ” Mensagem repetida para "${nomeGrupo}". Gerando nova...));
      mensagem = await gerarMensagemIA(nomeGrupo, grupo.id);
      tentativas++;
    }

    if (!ultimas.includes(mensagem.trim())) {
      await client.sendMessage(grupo.id, mensagem);
      await salvarMensagemNoHistorico(grupo.id, mensagem, nomeGrupo);
      console.log(chalk.green(ðŸ“¤ Mensagem enviada para "${nomeGrupo}"));
      return true;
    }

    return false;
  } catch (err) {
    console.error(chalk.red(âŒ Falha ao enviar mensagem para "${grupo.name}": ${err.message}));
    return false;
  }
}

// extrai o texto do pdf
const pdfParse = require('pdf-parse');
const { read } = require('fs');

async function gerarMensagemIA(nomeGrupoOuCurso, grupoId) {
  try {
    const pdfPath = path.join(__dirname, 'PDFs', ${grupoId}.pdf);

    // Verifica se o PDF existe
    let pdfText = '';
    try {
      const dataBuffer = await fs.readFile(pdfPath);
      const pdfData = await pdfParse(dataBuffer);
      pdfText = pdfData.text.trim().slice(0, 10000); // Limita para evitar excesso
    } catch (e) {
      console.warn(chalk.yellow(âš ï¸ PDF nÃ£o encontrado ou erro ao ler para o grupo ${grupoId}. Gerando mensagem genÃ©rica.));
    }

    // Prompt base
    const prompt = pdfText
      ? VocÃª Ã© uma pessoa que cuida de um grupo no WhatsApp de um curso chamado "${nomeGrupoOuCurso}". Com base nesse trecho do material do curso:\n\n"${pdfText}"\n\nEscreva uma mensagem de tamanho media e natural para o grupo, como se fosse um colega falando com os alunos. Evite parecer uma IA ou uma mensagem de marketing. Pode comentar algo que achou interessante do conteÃºdo, fazer uma pergunta para o grupo ou dar um toque simples, como um lembrete ou novidade. Nada de hashtags, listas, links ou mensagens muito longas.
      : Escreva uma mensagem curta e natural para um grupo de WhatsApp do curso "${nomeGrupoOuCurso}", como se fosse um colega animando os alunos. Pode dar uma dica, contar uma novidade ou sÃ³ puxar conversa. Evite listas, hashtags, links ou parecer uma IA. Use uma linguagem simples e direta.;

    const { data } = await axios.post(
      'https://api.groq.com/openai/v1/chat/completions',
      {
        model: 'meta-llama/llama-4-scout-17b-16e-instruct',
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.7,
        max_tokens: parseInt(process.env.OPENAI_MAX_TOKENS) || 3900
      },
      {
        headers: {
          'Authorization': Bearer ${OPENAI_API_KEY},
          'Content-Type': 'application/json'
        }
      }
    );
  
  const respostaIA = data?.choices?.[0]?.message?.content;
  if (!respostaIA) {
    throw new Error('Resposta da IA vazia ou invalida.');
  }

  return respostaIA.trim();
  } catch (err) {
    console.error(chalk.red(âŒ Erro ao gerar mensagem para grupo ${grupoId}:, err.message));
    return OlÃ¡! Hoje Ã© um bom momento para revisar os conteÃºdos do curso "${nomeGrupoOuCurso}". Em breve enviaremos novidades!;
  }
}